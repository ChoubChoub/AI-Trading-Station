#!/bin/bash

# =============================================================================
# ONLOAD-TRADING - LAYER 2 OF ULTRA-LOW LATENCY TRINITY
# PURPOSE: OnLoad kernel bypass with CPU pinning to isolated trading cores
# RESULT: Sub-microsecond network operations with zero kernel interference
# LATENCY IMPACT: Eliminates kernel stack overhead (~1.8Î¼s savings)
# =============================================================================

set -euo pipefail

SCRIPT_VERSION="1.0.0"
DEFAULT_CORES="2,3"
DEFAULT_MODE="auto"
LOG_FILE="/var/log/onload-trading.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    
    case "$level" in
        "INFO")  echo -e "${GREEN}[INFO]${NC} $message" ;;
        "WARN")  echo -e "${YELLOW}[WARN]${NC} $message" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} $message" ;;
        "DEBUG") echo -e "${BLUE}[DEBUG]${NC} $message" ;;
    esac
}

# Help function
show_help() {
    cat << EOF
OnLoad Trading - Ultra-Low Latency Trinity Layer 2
Version: $SCRIPT_VERSION

DESCRIPTION:
    Launches trading applications with OnLoad kernel bypass technology,
    CPU pinning to isolated trading cores, and zero-latency networking
    optimizations for consistent sub-microsecond execution times.

USAGE:
    $0 [OPTIONS] -- TRADING_COMMAND [ARGS...]

OPTIONS:
    --cores CORES          Trading cores for CPU pinning (default: $DEFAULT_CORES)
    --mode MODE           Execution mode: strict|onload-only|auto (default: $DEFAULT_MODE)
    --interface INTERFACE  Network interface to optimize (auto-detected)
    --profile PROFILE     OnLoad profile: latency|throughput|balanced (default: latency)
    --validate            Validate trinity setup before execution
    --dry-run            Show configuration without launching application
    --help               Show this help message

EXECUTION MODES:
    strict      - Require all optimizations (IRQ isolation + OnLoad + CPU pinning)
    onload-only - OnLoad + CPU pinning only (no IRQ validation required)
    auto        - Best available optimizations (graceful degradation)

ONLOAD PROFILES:
    latency     - Maximum responsiveness (EF_POLL_USEC=0, EF_INT_DRIVEN=0)
    throughput  - Maximum bandwidth (EF_RXQ_SIZE=16384, EF_TXQ_SIZE=16384)
    balanced    - Balanced latency/CPU usage (EF_POLL_USEC=10)

EXAMPLES:
    $0 --cores=2,3 --mode=strict -- ./trading_app --config=prod.json
    $0 --mode=onload-only -- python3 trading_bot.py
    $0 --validate --dry-run -- ./high_freq_trader
    $0 --profile=throughput --cores=2,3,4,5 -- ./market_maker

TRINITY ARCHITECTURE:
    Layer 1: IRQ isolation (configure-nic-irq-affinity.sh) 
    Layer 2 (this script): OnLoad kernel bypass + CPU pinning
    Layer 3: Trading application monitoring

PERFORMANCE IMPACT:
    - Bypasses entire kernel network stack (~1.8Î¼s savings)
    - Pins to isolated cores (~0.9Î¼s savings from context switching)
    - Direct userspace-to-NIC communication (~200ns latency)
    - Combined with Layer 1: <5Î¼s total latency achievable

PREREQUISITES:
    - OnLoad installed and configured
    - Sufficient CPU cores for isolation
    - Layer 1 IRQ isolation configured (for strict mode)
    - Trading application compatible with OnLoad

EOF
}

# Parse command line arguments
CORES="$DEFAULT_CORES"
MODE="$DEFAULT_MODE" 
INTERFACE=""
PROFILE="latency"
VALIDATE=false
DRY_RUN=false
TRADING_COMMAND=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --cores)
            CORES="$2"
            shift 2
            ;;
        --mode)
            MODE="$2"
            if [[ ! "$MODE" =~ ^(strict|onload-only|auto)$ ]]; then
                echo "Error: Invalid mode '$MODE'. Must be strict|onload-only|auto"
                exit 1
            fi
            shift 2
            ;;
        --interface)
            INTERFACE="$2"
            shift 2
            ;;
        --profile)
            PROFILE="$2"
            if [[ ! "$PROFILE" =~ ^(latency|throughput|balanced)$ ]]; then
                echo "Error: Invalid profile '$PROFILE'. Must be latency|throughput|balanced"
                exit 1
            fi
            shift 2
            ;;
        --validate)
            VALIDATE=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            show_help
            exit 0
            ;;
        --)
            shift
            TRADING_COMMAND=("$@")
            break
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Initialize logging
mkdir -p "$(dirname "$LOG_FILE")"
log_message "INFO" "Starting OnLoad trading configuration v$SCRIPT_VERSION"
log_message "INFO" "Mode: $MODE, Cores: $CORES, Profile: $PROFILE"

# Function to check OnLoad availability
check_onload_availability() {
    log_message "INFO" "Checking OnLoad availability"
    
    if ! command -v onload >/dev/null 2>&1; then
        log_message "ERROR" "OnLoad not found in PATH"
        log_message "ERROR" "Please install OnLoad from: https://www.xilinx.com/products/acceleration/onload.html"
        if [[ "$MODE" == "strict" || "$MODE" == "onload-only" ]]; then
            exit 1
        else
            log_message "WARN" "Continuing without OnLoad (auto mode)"
            return 1
        fi
    fi
    
    # Check OnLoad license
    if ! onload --version >/dev/null 2>&1; then
        log_message "WARN" "OnLoad version check failed - possible licensing issue"
    fi
    
    # Check if OnLoad kernel modules are loaded
    if ! lsmod | grep -q onload; then
        log_message "WARN" "OnLoad kernel modules not loaded"
        log_message "INFO" "Attempting to load OnLoad modules"
        if ! onload_tool reload >/dev/null 2>&1; then
            log_message "WARN" "Failed to load OnLoad modules automatically"
        fi
    fi
    
    log_message "INFO" "âœ“ OnLoad available and configured"
    return 0
}

# Function to validate CPU cores
validate_cpu_cores() {
    local cpu_count=$(nproc)
    local max_core=$((cpu_count - 1))
    
    log_message "INFO" "Validating CPU core configuration"
    log_message "INFO" "System has $cpu_count CPU cores (0-$max_core)"
    
    # Check if cores exist
    for core in $(echo "$CORES" | tr ',' ' '); do
        if [[ $core -gt $max_core ]]; then
            log_message "ERROR" "Trading core $core does not exist (max: $max_core)"
            exit 1
        fi
    done
    
    # Check if cores are isolated (for strict mode)
    if [[ "$MODE" == "strict" ]] && grep -q "isolcpus" /proc/cmdline; then
        local isolated_cores=$(grep -o 'isolcpus=[^ ]*' /proc/cmdline | cut -d= -f2)
        for core in $(echo "$CORES" | tr ',' ' '); do
            if [[ ! "$isolated_cores" =~ $core ]]; then
                log_message "WARN" "Trading core $core not in kernel isolcpus parameter"
                log_message "WARN" "For optimal performance, add 'isolcpus=$CORES' to kernel command line"
            fi
        done
    fi
    
    log_message "INFO" "âœ“ CPU cores validated: $CORES"
}

# Function to detect primary network interface
detect_primary_interface() {
    if [[ -n "$INTERFACE" ]]; then
        log_message "INFO" "Using specified interface: $INTERFACE"
        return
    fi
    
    # Get interface used for default route
    local primary_interface=$(ip route | grep '^default' | head -1 | sed 's/.*dev \([^ ]*\).*/\1/')
    
    if [[ -z "$primary_interface" ]]; then
        log_message "WARN" "Could not detect primary network interface"
        log_message "WARN" "OnLoad optimizations may not be fully effective"
        return
    fi
    
    INTERFACE="$primary_interface"
    log_message "INFO" "Auto-detected primary interface: $INTERFACE"
}

# Function to validate Layer 1 IRQ isolation
validate_irq_isolation() {
    if [[ "$MODE" != "strict" ]]; then
        log_message "INFO" "Skipping IRQ isolation validation (mode: $MODE)"
        return 0
    fi
    
    log_message "INFO" "Validating Layer 1 IRQ isolation"
    
    # Check if IRQ affinity configuration script exists
    if [[ ! -x "./scripts/configure-nic-irq-affinity.sh" ]]; then
        log_message "ERROR" "IRQ affinity configuration script not found or not executable"
        log_message "ERROR" "Please run: sudo ./scripts/configure-nic-irq-affinity.sh"
        exit 1
    fi
    
    # Check if IRQ isolation is active
    if [[ -f "/var/log/nic-irq-affinity.log" ]]; then
        if tail -10 "/var/log/nic-irq-affinity.log" | grep -q "LAYER 1 CONFIGURATION COMPLETE"; then
            log_message "INFO" "âœ“ Layer 1 IRQ isolation appears to be configured"
        else
            log_message "WARN" "IRQ isolation log exists but may not be current"
            log_message "WARN" "Consider running: sudo ./scripts/configure-nic-irq-affinity.sh --status"
        fi
    else
        log_message "ERROR" "No IRQ isolation configuration found"
        log_message "ERROR" "Please run: sudo ./scripts/configure-nic-irq-affinity.sh"
        exit 1
    fi
}

# Function to build OnLoad environment variables
build_onload_env() {
    local env_vars=()
    
    log_message "INFO" "Building OnLoad environment for profile: $PROFILE"
    
    # Base OnLoad settings
    env_vars+=("EF_NAME=trading_${PROFILE}")
    env_vars+=("EF_LOG_LEVEL=ERR")  # Minimize logging for performance
    
    case "$PROFILE" in
        "latency")
            # Maximum responsiveness settings
            env_vars+=("EF_POLL_USEC=0")           # Busy polling, no sleeping
            env_vars+=("EF_INT_DRIVEN=0")          # Disable interrupt-driven mode  
            env_vars+=("EF_RX_TIMESTAMPING=0")     # Disable timestamping overhead
            env_vars+=("EF_TX_TIMESTAMPING=0")     # Disable timestamping overhead
            env_vars+=("EF_KERNEL_PACKETS_TIMER=0") # Disable kernel packet timer
            env_vars+=("EF_RXQ_SIZE=2048")         # Moderate queue size for latency
            env_vars+=("EF_TXQ_SIZE=2048")         # Moderate queue size for latency
            env_vars+=("EF_PREEMPTIBLE_POLLS=0")   # Non-preemptible polling
            log_message "INFO" "Configured for minimum latency (busy polling)"
            ;;
        "throughput")
            # Maximum bandwidth settings
            env_vars+=("EF_POLL_USEC=50")          # Balanced polling
            env_vars+=("EF_INT_DRIVEN=1")          # Enable interrupts for efficiency
            env_vars+=("EF_RXQ_SIZE=16384")        # Large receive queue
            env_vars+=("EF_TXQ_SIZE=16384")        # Large transmit queue
            env_vars+=("EF_MAX_ENDPOINTS=1024")    # Support many connections
            env_vars+=("EF_NETIF_DTOR_DELAY=5000") # Delayed destruction
            log_message "INFO" "Configured for maximum throughput"
            ;;
        "balanced")
            # Balanced latency and CPU usage
            env_vars+=("EF_POLL_USEC=10")          # Light polling
            env_vars+=("EF_INT_DRIVEN=1")          # Use interrupts when idle
            env_vars+=("EF_RXQ_SIZE=4096")         # Balanced queue size
            env_vars+=("EF_TXQ_SIZE=4096")         # Balanced queue size
            env_vars+=("EF_PREEMPTIBLE_POLLS=1")   # Allow preemption
            log_message "INFO" "Configured for balanced performance"
            ;;
    esac
    
    # Interface-specific optimization
    if [[ -n "$INTERFACE" ]]; then
        env_vars+=("EF_INTERFACE_WHITELIST=$INTERFACE")
        log_message "INFO" "OnLoad restricted to interface: $INTERFACE"
    fi
    
    printf '%s\n' "${env_vars[@]}"
}

# Function to build CPU pinning command
build_cpu_pinning() {
    local cpu_list="$CORES"
    local pinning_cmd=""
    
    # Use taskset for CPU pinning
    if command -v taskset >/dev/null 2>&1; then
        pinning_cmd="taskset -c $cpu_list"
        log_message "INFO" "Using taskset for CPU pinning to cores: $cpu_list"
    else
        log_message "WARN" "taskset not available - no CPU pinning"
        return
    fi
    
    echo "$pinning_cmd"
}

# Function to validate trading command
validate_trading_command() {
    if [[ ${#TRADING_COMMAND[@]} -eq 0 ]]; then
        log_message "ERROR" "No trading command specified"
        log_message "ERROR" "Usage: $0 [OPTIONS] -- TRADING_COMMAND [ARGS...]"
        exit 1
    fi
    
    local command_name="${TRADING_COMMAND[0]}"
    
    # Check if command exists
    if [[ "$command_name" == "./"* ]] || [[ "$command_name" == "/"* ]]; then
        # Absolute or relative path
        if [[ ! -x "$command_name" ]]; then
            log_message "ERROR" "Trading command not found or not executable: $command_name"
            exit 1
        fi
    else
        # Command in PATH
        if ! command -v "$command_name" >/dev/null 2>&1; then
            log_message "ERROR" "Trading command not found in PATH: $command_name"
            exit 1
        fi
    fi
    
    log_message "INFO" "âœ“ Trading command validated: ${TRADING_COMMAND[*]}"
}

# Function to show configuration summary
show_configuration() {
    log_message "INFO" "=== OnLoad Trading Configuration Summary ==="
    log_message "INFO" "Mode: $MODE"
    log_message "INFO" "CPU Cores: $CORES"
    log_message "INFO" "OnLoad Profile: $PROFILE"
    log_message "INFO" "Network Interface: ${INTERFACE:-auto-detected}"
    log_message "INFO" "Trading Command: ${TRADING_COMMAND[*]}"
    
    echo ""
    log_message "INFO" "Performance Expectations:"
    case "$PROFILE" in
        "latency")
            log_message "INFO" "- Network latency: ~200ns (direct userspace)"
            log_message "INFO" "- CPU usage: High (busy polling)"
            log_message "INFO" "- Best for: HFT, ultra-low latency trading"
            ;;
        "throughput")
            log_message "INFO" "- Network bandwidth: Maximum available"
            log_message "INFO" "- CPU usage: Moderate (interrupt-driven)"
            log_message "INFO" "- Best for: High-volume trading, market data"
            ;;
        "balanced")
            log_message "INFO" "- Network latency: ~1-2Î¼s (balanced polling)"
            log_message "INFO" "- CPU usage: Low to moderate"
            log_message "INFO" "- Best for: General trading applications"
            ;;
    esac
    echo ""
}

# Function to execute trading application
execute_trading_application() {
    local onload_available=true
    local env_vars=()
    local full_command=()
    
    # Check OnLoad availability
    if ! check_onload_availability; then
        onload_available=false
        if [[ "$MODE" == "strict" || "$MODE" == "onload-only" ]]; then
            log_message "ERROR" "OnLoad required but not available in mode: $MODE"
            exit 1
        fi
    fi
    
    # Build environment variables
    if [[ "$onload_available" == "true" ]]; then
        readarray -t env_vars < <(build_onload_env)
    fi
    
    # Build CPU pinning command
    local pinning_cmd=$(build_cpu_pinning)
    
    # Construct full command
    if [[ -n "$pinning_cmd" ]]; then
        full_command+=($pinning_cmd)
    fi
    
    if [[ "$onload_available" == "true" ]]; then
        full_command+=("onload" "--profile=$PROFILE")
    fi
    
    full_command+=("${TRADING_COMMAND[@]}")
    
    # Show what will be executed
    log_message "INFO" "=== Executing Trading Application ==="
    if [[ ${#env_vars[@]} -gt 0 ]]; then
        log_message "INFO" "OnLoad Environment Variables:"
        for var in "${env_vars[@]}"; do
            log_message "INFO" "  export $var"
        done
    fi
    
    log_message "INFO" "Full Command: ${full_command[*]}"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_message "INFO" "[DRY RUN] Would execute the above command"
        log_message "INFO" "Expected performance improvements:"
        if [[ "$onload_available" == "true" ]]; then
            log_message "INFO" "  - OnLoad kernel bypass: ~1.8Î¼s latency reduction"
        fi
        if [[ -n "$pinning_cmd" ]]; then
            log_message "INFO" "  - CPU pinning: ~0.9Î¼s jitter reduction"
        fi
        return 0
    fi
    
    # Set environment variables
    for var in "${env_vars[@]}"; do
        export "$var"
    done
    
    # Execute the command
    log_message "INFO" "ðŸš€ Launching trading application with Layer 2 optimizations"
    log_message "INFO" "Process will be pinned to cores: $CORES"
    
    # Execute and capture the PID for monitoring
    exec "${full_command[@]}" &
    local trading_pid=$!
    
    log_message "INFO" "Trading application launched with PID: $trading_pid"
    log_message "INFO" "Monitor with: ps -p $trading_pid -o pid,ppid,psr,comm,args"
    
    # Wait for the process
    wait $trading_pid
    local exit_code=$?
    
    log_message "INFO" "Trading application exited with code: $exit_code"
    exit $exit_code
}

# Function to run full trinity validation
validate_trinity() {
    log_message "INFO" "=== Full Trinity Validation ==="
    
    # Layer 1: IRQ isolation
    validate_irq_isolation
    
    # Layer 2: OnLoad and CPU configuration
    check_onload_availability
    validate_cpu_cores
    detect_primary_interface
    
    # Layer 3: Application readiness
    validate_trading_command
    
    log_message "INFO" "âœ“ All trinity layers validated successfully"
    log_message "INFO" "Expected combined performance: <5Î¼s latency"
}

# Main execution
main() {
    validate_cpu_cores
    detect_primary_interface
    validate_trading_command
    
    if [[ "$VALIDATE" == "true" ]]; then
        validate_trinity
    fi
    
    if [[ "$MODE" == "strict" ]]; then
        validate_irq_isolation
    fi
    
    show_configuration
    execute_trading_application
}

# Execute main function
main "$@"